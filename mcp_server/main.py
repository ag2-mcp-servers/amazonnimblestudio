# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:53:23+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    AcceptEulasResponse,
    AccessDeniedException,
    ConflictException,
    CreateLaunchProfileResponse,
    CreateStreamingImageResponse,
    CreateStreamingSessionResponse,
    CreateStreamingSessionStreamResponse,
    CreateStudioComponentResponse,
    CreateStudioResponse,
    DeleteLaunchProfileMemberResponse,
    DeleteLaunchProfileResponse,
    DeleteStreamingImageResponse,
    DeleteStreamingSessionResponse,
    DeleteStudioComponentResponse,
    DeleteStudioMemberResponse,
    DeleteStudioResponse,
    EulaIds,
    Field20200801StudiosPostRequest,
    Field20200801StudiosStudioIdEulaAcceptancesPostRequest,
    Field20200801StudiosStudioIdLaunchProfilesLaunchProfileIdMembershipPostRequest,
    Field20200801StudiosStudioIdLaunchProfilesLaunchProfileIdMembershipPrincipalIdPatchRequest,
    Field20200801StudiosStudioIdLaunchProfilesLaunchProfileIdPatchRequest,
    Field20200801StudiosStudioIdLaunchProfilesPostRequest,
    Field20200801StudiosStudioIdMembershipPostRequest,
    Field20200801StudiosStudioIdPatchRequest,
    Field20200801StudiosStudioIdStreamingImagesPostRequest,
    Field20200801StudiosStudioIdStreamingImagesStreamingImageIdPatchRequest,
    Field20200801StudiosStudioIdStreamingSessionsPostRequest,
    Field20200801StudiosStudioIdStreamingSessionsSessionIdStartPostRequest,
    Field20200801StudiosStudioIdStreamingSessionsSessionIdStopPostRequest,
    Field20200801StudiosStudioIdStreamingSessionsSessionIdStreamsPostRequest,
    Field20200801StudiosStudioIdStudioComponentsPostRequest,
    Field20200801StudiosStudioIdStudioComponentsStudioComponentIdPatchRequest,
    Field20200801TagsResourceArnPostRequest,
    GetEulaResponse,
    GetLaunchProfileDetailsResponse,
    GetLaunchProfileInitializationResponse,
    GetLaunchProfileMemberResponse,
    GetLaunchProfileResponse,
    GetStreamingImageResponse,
    GetStreamingSessionBackupResponse,
    GetStreamingSessionResponse,
    GetStreamingSessionStreamResponse,
    GetStudioComponentResponse,
    GetStudioMemberResponse,
    GetStudioResponse,
    InternalServerErrorException,
    LaunchProfileProtocolVersions,
    ListEulaAcceptancesResponse,
    ListEulasResponse,
    ListLaunchProfileMembersResponse,
    ListLaunchProfilesResponse,
    ListStreamingImagesResponse,
    ListStreamingSessionBackupsResponse,
    ListStreamingSessionsResponse,
    ListStudioComponentsResponse,
    ListStudioMembersResponse,
    ListStudiosResponse,
    ListTagsForResourceResponse,
    PutLaunchProfileMembersResponse,
    PutStudioMembersResponse,
    ResourceNotFoundException,
    ServiceQuotaExceededException,
    StartStreamingSessionResponse,
    StartStudioSSOConfigurationRepairResponse,
    States,
    States1,
    StopStreamingSessionResponse,
    TagKeys,
    TagResourceResponse,
    ThrottlingException,
    Types,
    UntagResourceResponse,
    UpdateLaunchProfileMemberResponse,
    UpdateLaunchProfileResponse,
    UpdateStreamingImageResponse,
    UpdateStudioComponentResponse,
    UpdateStudioResponse,
    ValidationException,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='<p>Welcome to the Amazon Nimble Studio API reference. This API reference provides methods, schema, resources, parameters, and more to help you get the most out of Nimble Studio.</p> <p>Nimble Studio is a virtual studio that empowers visual effects, animation, and interactive content teams to create content securely within a scalable, private cloud service.</p>',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='AmazonNimbleStudio',
    version='2020-08-01',
    servers=[
        {
            'description': 'The AmazonNimbleStudio multi-region endpoint',
            'url': 'http://nimble.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AmazonNimbleStudio multi-region endpoint',
            'url': 'https://nimble.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AmazonNimbleStudio endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://nimble.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The AmazonNimbleStudio endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://nimble.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/2020-08-01/eulas',
    description=""" List EULAs. """,
    tags=['eula_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_eulas(
    eula_ids: Optional[EulaIds] = Query(None, alias='eulaIds'),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/eulas/{eulaId}',
    description=""" Get EULA. """,
    tags=['eula_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_eula(
    eula_id: str = Path(..., alias='eulaId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios',
    description=""" List studios in your Amazon Web Services accounts in the requested Amazon Web Services Region. """,
    tags=['streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_studios(
    next_token: Optional[str] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios',
    description=""" <p>Create a new studio.</p> <p>When creating a studio, two IAM roles must be provided: the admin role and the user role. These roles are assumed by your users when they log in to the Nimble Studio portal.</p> <p>The user role must have the <code>AmazonNimbleStudio-StudioUser</code> managed policy attached for the portal to function properly.</p> <p>The admin role must have the <code>AmazonNimbleStudio-StudioAdmin</code> managed policy attached for the portal to function properly.</p> <p>You may optionally specify a KMS key in the <code>StudioEncryptionConfiguration</code>.</p> <p>In Nimble Studio, resource names, descriptions, initialization scripts, and other data you provide are always encrypted at rest using an KMS key. By default, this key is owned by Amazon Web Services and managed on your behalf. You may provide your own KMS key when calling <code>CreateStudio</code> to encrypt this data using a key you own and manage.</p> <p>When providing an KMS key during studio creation, Nimble Studio creates KMS grants in your account to provide your studio user and admin roles access to these KMS keys.</p> <p>If you delete this grant, the studio will no longer be accessible to your portal users.</p> <p>If you delete the studio KMS key, your studio will no longer be accessible.</p> """,
    tags=['streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_studio(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2020-08-01/studios/{studioId}',
    description=""" Delete a studio resource. """,
    tags=[
        'studio_entity_management',
        'studio_member_operations',
        'streaming_session_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_studio(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}',
    description=""" Get a studio resource. """,
    tags=['studio_entity_management', 'studio_member_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_studio(
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/2020-08-01/studios/{studioId}',
    description=""" <p>Update a Studio resource.</p> <p>Currently, this operation only supports updating the displayName of your studio.</p> """,
    tags=['studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_studio(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/eula-acceptances',
    description=""" List EULA acceptances. """,
    tags=['eula_management', 'studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_eula_acceptances(
    eula_ids: Optional[EulaIds] = Query(None, alias='eulaIds'),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios/{studioId}/eula-acceptances',
    description=""" Accept EULAs. """,
    tags=['eula_management', 'studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def accept_eulas(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdEulaAcceptancesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/launch-profiles',
    description=""" List all the launch profiles a studio. """,
    tags=['studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_launch_profiles(
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='maxResults'),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    principal_id: Optional[str] = Query(None, alias='principalId'),
    states: Optional[States] = None,
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios/{studioId}/launch-profiles',
    description=""" Create a launch profile. """,
    tags=['launch_profile_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_launch_profile(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdLaunchProfilesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}',
    description=""" Permanently delete a launch profile. """,
    tags=['launch_profile_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_launch_profile(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    launch_profile_id: str = Path(..., alias='launchProfileId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}',
    description=""" Get a launch profile. """,
    tags=['launch_profile_handling', 'studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_launch_profile(
    launch_profile_id: str = Path(..., alias='launchProfileId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}',
    description=""" Update a launch profile. """,
    tags=['launch_profile_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_launch_profile(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    launch_profile_id: str = Path(..., alias='launchProfileId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdLaunchProfilesLaunchProfileIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/details',
    description=""" Launch profile details include the launch profile resource and summary information of resources that are used by, or available to, the launch profile. This includes the name and description of all studio components used by the launch profiles, and the name and description of streaming images that can be used with this launch profile. """,
    tags=['launch_profile_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_launch_profile_details(
    launch_profile_id: str = Path(..., alias='launchProfileId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/init#launchProfileProtocolVersions&launchPurpose&platform',
    description=""" Get a launch profile initialization. """,
    tags=['launch_profile_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_launch_profile_initialization(
    launch_profile_id: str = Path(..., alias='launchProfileId'),
    launch_profile_protocol_versions: LaunchProfileProtocolVersions = Query(
        ..., alias='launchProfileProtocolVersions'
    ),
    launch_purpose: str = Query(..., alias='launchPurpose'),
    platform: str = ...,
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/membership',
    description=""" Get all users in a given launch profile membership. """,
    tags=['launch_profile_handling', 'studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_launch_profile_members(
    launch_profile_id: str = Path(..., alias='launchProfileId'),
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='maxResults'),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/membership',
    description=""" Add/update users with given persona to launch profile membership. """,
    tags=['launch_profile_handling', 'studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_launch_profile_members(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    launch_profile_id: str = Path(..., alias='launchProfileId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdLaunchProfilesLaunchProfileIdMembershipPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/membership/{principalId}',
    description=""" Delete a user from launch profile membership. """,
    tags=['launch_profile_handling', 'studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_launch_profile_member(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    launch_profile_id: str = Path(..., alias='launchProfileId'),
    principal_id: str = Path(..., alias='principalId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/membership/{principalId}',
    description=""" Get a user persona in launch profile membership. """,
    tags=['launch_profile_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_launch_profile_member(
    launch_profile_id: str = Path(..., alias='launchProfileId'),
    principal_id: str = Path(..., alias='principalId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/membership/{principalId}',
    description=""" Update a user persona in launch profile membership. """,
    tags=['launch_profile_handling', 'studio_member_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_launch_profile_member(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    launch_profile_id: str = Path(..., alias='launchProfileId'),
    principal_id: str = Path(..., alias='principalId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdLaunchProfilesLaunchProfileIdMembershipPrincipalIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/membership',
    description=""" <p>Get all users in a given studio membership.</p> <note> <p> <code>ListStudioMembers</code> only returns admin members.</p> </note> """,
    tags=[
        'studio_entity_management',
        'studio_member_operations',
        'streaming_session_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_studio_members(
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='maxResults'),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios/{studioId}/membership',
    description=""" Add/update users with given persona to studio membership. """,
    tags=['studio_member_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_studio_members(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdMembershipPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2020-08-01/studios/{studioId}/membership/{principalId}',
    description=""" Delete a user from studio membership. """,
    tags=[
        'studio_entity_management',
        'studio_member_operations',
        'streaming_image_lifecycle_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_studio_member(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    principal_id: str = Path(..., alias='principalId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/membership/{principalId}',
    description=""" Get a user's membership in a studio. """,
    tags=['studio_entity_management', 'studio_member_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_studio_member(
    principal_id: str = Path(..., alias='principalId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/2020-08-01/studios/{studioId}/sso-configuration',
    description=""" <p>Repairs the IAM Identity Center configuration for a given studio.</p> <p>If the studio has a valid IAM Identity Center configuration currently associated with it, this operation will fail with a validation error.</p> <p>If the studio does not have a valid IAM Identity Center configuration currently associated with it, then a new IAM Identity Center application is created for the studio and the studio is changed to the <code>READY</code> state.</p> <p>After the IAM Identity Center application is repaired, you must use the Amazon Nimble Studio console to add administrators and users to your studio.</p> """,
    tags=['studio_member_operations', 'studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_studio_s_s_o_configuration_repair(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/streaming-images',
    description=""" <p>List the streaming image resources available to this studio.</p> <p>This list will contain both images provided by Amazon Web Services, as well as streaming images that you have created in your studio.</p> """,
    tags=['studio_entity_management', 'studio_member_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_streaming_images(
    next_token: Optional[str] = Query(None, alias='nextToken'),
    owner: Optional[str] = None,
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios/{studioId}/streaming-images',
    description=""" Creates a streaming image resource in a studio. """,
    tags=['studio_entity_management', 'streaming_image_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_streaming_image(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdStreamingImagesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2020-08-01/studios/{studioId}/streaming-images/{streamingImageId}',
    description=""" Delete streaming image. """,
    tags=['streaming_image_lifecycle_management', 'streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_streaming_image(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    streaming_image_id: str = Path(..., alias='streamingImageId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/streaming-images/{streamingImageId}',
    description=""" Get streaming image. """,
    tags=['streaming_image_lifecycle_management', 'streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_streaming_image(
    streaming_image_id: str = Path(..., alias='streamingImageId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/2020-08-01/studios/{studioId}/streaming-images/{streamingImageId}',
    description=""" Update streaming image. """,
    tags=['streaming_image_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_streaming_image(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    streaming_image_id: str = Path(..., alias='streamingImageId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdStreamingImagesStreamingImageIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/streaming-session-backups',
    description=""" Lists the backups of a streaming session in a studio. """,
    tags=['studio_entity_management', 'studio_component_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_streaming_session_backups(
    next_token: Optional[str] = Query(None, alias='nextToken'),
    owned_by: Optional[str] = Query(None, alias='ownedBy'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/streaming-session-backups/{backupId}',
    description=""" <p>Gets <code>StreamingSessionBackup</code> resource.</p> <p>Invoke this operation to poll for a streaming session backup while stopping a streaming session.</p> """,
    tags=['streaming_session_backup_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_streaming_session_backup(
    backup_id: str = Path(..., alias='backupId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/streaming-sessions',
    description=""" Lists the streaming sessions in a studio. """,
    tags=['studio_entity_management', 'streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_streaming_sessions(
    created_by: Optional[str] = Query(None, alias='createdBy'),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    owned_by: Optional[str] = Query(None, alias='ownedBy'),
    session_ids: Optional[str] = Query(None, alias='sessionIds'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios/{studioId}/streaming-sessions',
    description=""" <p>Creates a streaming session in a studio.</p> <p>After invoking this operation, you must poll GetStreamingSession until the streaming session is in the <code>READY</code> state.</p> """,
    tags=['streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_streaming_session(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdStreamingSessionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}',
    description=""" <p>Deletes streaming session resource.</p> <p>After invoking this operation, use GetStreamingSession to poll the resource until it transitions to a <code>DELETED</code> state.</p> <p>A streaming session will count against your streaming session quota until it is marked <code>DELETED</code>.</p> """,
    tags=['streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_streaming_session(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    session_id: str = Path(..., alias='sessionId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}',
    description=""" <p>Gets StreamingSession resource.</p> <p>Invoke this operation to poll for a streaming session state while creating or deleting a session.</p> """,
    tags=['streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_streaming_session(
    session_id: str = Path(..., alias='sessionId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}/start',
    description=""" Transitions sessions from the <code>STOPPED</code> state into the <code>READY</code> state. The <code>START_IN_PROGRESS</code> state is the intermediate state between the <code>STOPPED</code> and <code>READY</code> states. """,
    tags=['streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_streaming_session(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    session_id: str = Path(..., alias='sessionId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdStreamingSessionsSessionIdStartPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}/stop',
    description=""" Transitions sessions from the <code>READY</code> state into the <code>STOPPED</code> state. The <code>STOP_IN_PROGRESS</code> state is the intermediate state between the <code>READY</code> and <code>STOPPED</code> states. """,
    tags=['streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def stop_streaming_session(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    session_id: str = Path(..., alias='sessionId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdStreamingSessionsSessionIdStopPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}/streams',
    description=""" <p>Creates a streaming session stream for a streaming session.</p> <p>After invoking this API, invoke GetStreamingSessionStream with the returned streamId to poll the resource until it is in the <code>READY</code> state.</p> """,
    tags=['streaming_session_operations', 'studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_streaming_session_stream(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    session_id: str = Path(..., alias='sessionId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdStreamingSessionsSessionIdStreamsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}/streams/{streamId}',
    description=""" <p>Gets a StreamingSessionStream for a streaming session.</p> <p>Invoke this operation to poll the resource after invoking <code>CreateStreamingSessionStream</code>.</p> <p>After the <code>StreamingSessionStream</code> changes to the <code>READY</code> state, the url property will contain a stream to be used with the DCV streaming client.</p> """,
    tags=['streaming_session_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_streaming_session_stream(
    session_id: str = Path(..., alias='sessionId'),
    stream_id: str = Path(..., alias='streamId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/studio-components',
    description=""" Lists the <code>StudioComponents</code> in a studio. """,
    tags=['studio_entity_management', 'studio_component_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_studio_components(
    max_results: Optional[conint(ge=1, le=100)] = Query(None, alias='maxResults'),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    states: Optional[States1] = None,
    studio_id: str = Path(..., alias='studioId'),
    types: Optional[Types] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/studios/{studioId}/studio-components',
    description=""" Creates a studio component resource. """,
    tags=['studio_component_operations', 'studio_entity_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_studio_component(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdStudioComponentsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2020-08-01/studios/{studioId}/studio-components/{studioComponentId}',
    description=""" Deletes a studio component resource. """,
    tags=['studio_component_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_studio_component(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_component_id: str = Path(..., alias='studioComponentId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/studios/{studioId}/studio-components/{studioComponentId}',
    description=""" Gets a studio component resource. """,
    tags=['studio_component_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_studio_component(
    studio_component_id: str = Path(..., alias='studioComponentId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/2020-08-01/studios/{studioId}/studio-components/{studioComponentId}',
    description=""" Updates a studio component resource. """,
    tags=['studio_component_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_studio_component(
    x__amz__client__token: Optional[constr(min_length=1, max_length=64)] = Header(
        None, alias='X-Amz-Client-Token'
    ),
    studio_component_id: str = Path(..., alias='studioComponentId'),
    studio_id: str = Path(..., alias='studioId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801StudiosStudioIdStudioComponentsStudioComponentIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2020-08-01/tags/{resourceArn}',
    description=""" <p>Gets the tags for a resource, given its Amazon Resource Names (ARN).</p> <p>This operation supports ARNs for all resource types in Nimble Studio that support tags, including studio, studio component, launch profile, streaming image, and streaming session. All resources that can be tagged will contain an ARN property, so you do not have to create this ARN yourself.</p> """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    resource_arn: str = Path(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2020-08-01/tags/{resourceArn}',
    description=""" Creates tags for a resource, given its ARN. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: str = Path(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20200801TagsResourceArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2020-08-01/tags/{resourceArn}#tagKeys',
    description=""" Deletes the tags for a resource. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: str = Path(..., alias='resourceArn'),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
